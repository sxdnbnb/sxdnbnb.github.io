---
date: 2024-08-09 20:53:24
description: MySQL 索引优化规则总结
title: MySQL 索引
tags:
  - 数据库
permalink: /database/index
coverImg:
  - /img/13.jpg
categories:
  - 数据库
---

# MySQL 索引优化规则总结

## 1.`like`语句的前导模糊查询不能使用索引

```sql
select * from test where title like '%XX'；   --不能使用索引
select * from test where title like 'XX%'；   --非前导模糊查询，可以使用索引
```
## 2.`union、in、or` 都能够命中索引，建议使用 `in`；
(1) `union`能够命中索引，并且MySQL 耗费的 CPU 最少。
(2) `in` 能够命中索引，查询优化耗费的 CPU 比 union all 多，但可以忽略不计，一般情况下建议使用 `in`。
(3) `or` 查询优化耗费的 CPU 比 `in` 多，不建议频繁用 `or`;

## 3.负向条件查询不能使用索引
 负向条件有：`!=、<>、not in、not exists、not like` 等。

## 4.联合索引最左前缀原则
（1） 如果在 (a,b,c) 三个字段上建立联合索引，那么他会自动建立a| (a,b) | (a,b,c) 组索引。
（2）建立联合索引的时候，区分度最高的字段在最左边。
（3）存在非等号和等号混合判断条件时，在建立索引时，把等号条件的列前置。如 `where a>? and b=?`，那么即使 a 的区分度更高，也必须把 b 放在索引的最前列。

## 5.不能使用索引中范围条件右边的列（范围列可以用到索引），范围列之后列的索引全失效
（1）范围条件有：`<、<=、>、>=、between`等。
（2）索引最多用于一个范围列，如果查询条件中有两个范围列则无法全用到索引。
（3）假如有联合索引 (a、b、c)，那么下面的 SQL 中 a 可以用到索引，而b 和 c 则使用不到索引。

`select * from test where a < 10010' and b=4 and c between 1 and 4`

## 6.不要在索引列上面做任何操作（计算、函数）
会导致索引失效而转向全表扫描。

## 7.强制类型转换会全表扫描
（1）字符串类型不加单引号会导致索引失效，因为mysql会自己做类型转换,相当于在索引列上进行了操作。如果 a 字段是 `varchar` 类型，则下面的 SQL 不能命中索引。
`select * from user where a=13800001234`

## 8.更新十分频繁、数据区分度不高的列不宜建立索引
（1）更新会变更 B+ 树，更新频繁的字段建立索引会大大降低数据库性能。
（2）“性别”这种区分度不大的属性，建立索引是没有什么意义的，不能有效过滤数据，性能与全表扫描类似。
（3）一般区分度在80%以上的时候就可以建立索引，区分度可以使用 `count(distinct(列名))/count(*)` 来计算。

## 9.利用覆盖索引来进行查询操作，避免回表，减少`select *` 的使用。
（1）覆盖索引：查询的列和所建立的索引的列个数相同，字段相同。
（2）被查询的列，数据能从索引中取得，而不用通过行定位符 row-locator 再到 row 上获取，即“被查询列要被所建的索引覆盖”，这能够加速查询速度。

## 10.索引不会包含有`NULL`值的列
（1）只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时，尽量使用`not null` 约束以及默认值。

## 11.`is null, is not null`无法使用索引

## 12.如果有`order by、group by`的场景，注意利用索引的有序性
（1）order by 最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现`file_sort` 的情况，影响查询性能。
例如对于语句 `where a=? and b=? order by c`，可以建立联合索引(a,b,c)。
（2）如果索引中有范围查找，那么索引有序性无法利用，如`WHERE a>10 ORDER BY b`;，索引(a,b)无法排序。

## 13.使用短索引（前缀索引）
（1）- 对列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个CHAR(255)的列，如果该列在前10个或20个字符内，可以做到既使得前缀索引的区分度接近全列索引，那么就不要对整个列进行索引。因为短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作，减少索引文件的维护开销。可以使用`count(distinct leftIndex(列名, 索引长度))/count(*)` 来计算前缀索引的区分度。
（2） 但缺点是不能用于 `ORDER BY` 和 `GROUP BY` 操作，也不能用于覆盖索引。
（3）不过很多时候没必要对全字段建立索引，根据实际文本区分度决定索引长度即可。

## 14.利用延迟关联或者子查询优化超多分页场景
（1）MySQL 并不是跳过 `offset` 行，而是取` offset + N` 行，然后返回放弃前 `offset` 行，返回 N 行，那当 offset 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行 SQL 改写。示例如下，先快速定位需要获取的id段，然后再关联:
`select a.* from 表1 a,(select id from 表1 where 条件 limit100000,20 ) b where a.id=b.id；`
## 15.如果明确知道只有一条结果返回，`limit 1` 能够提高效率

## 16.超过三个表最好不要 `join`

## 17.单表索引建议控制在5个以内

## 18.SQL 性能优化 explain 中的 type
至少要达到 range 级别，要求是 ref 级别，如果可以是 consts 最好
（1）consts：单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。
（2）ref：使用普通的索引（Normal Index）。
（3）range：对索引进行范围检索。
（4）当 type=index 时，索引物理文件全扫，速度非常慢。

## 19.业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引